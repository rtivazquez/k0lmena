var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default,
  withPerformanceTracking: () => withPerformanceTracking
});
module.exports = __toCommonJS(src_exports);
var core = __toESM(require("@actions/core"));
var import_ci_info = require("ci-info");
var import_debug = __toESM(require("debug"));
var fs = __toESM(require("fs"));
var import_got = __toESM(require("got"));
var import_nanoid = require("nanoid");
var import_node_crypto = __toESM(require("crypto"));
var import_node_os = __toESM(require("os"));
var path = __toESM(require("path"));
var process2 = __toESM(require("process"));
var import_promises = require("timers/promises");

// package.json
var version = "1.1.2";

// src/utils/github-comment.ts
var github = __toESM(require("@actions/github"));
var COMMENT_TAG = "<!-- artillery-playwright-report -->";
var TITLE = "## \u{1F3AD} Artillery Playwright Reporter";
var TABLE_HEADER = "\n| Status | Test results | Updated (UTC) |\n| :---- | :------ | :------- |";
async function createOrUpdateComment(input) {
  var _a, _b, _c, _d;
  if (process.env.GITHUB_ACTIONS !== "true") {
    return null;
  }
  const githubToken = process.env.GITHUB_TOKEN;
  if (!githubToken) {
    console.log("No GITHUB_TOKEN available, skipping comment creation");
    return null;
  }
  const context2 = github.context;
  const octokit = github.getOctokit(githubToken);
  let issueNumber = ((_a = context2.payload.pull_request) == null ? void 0 : _a.number) || ((_b = context2.payload.issue) == null ? void 0 : _b.number);
  if (!issueNumber) {
    try {
      const commitSha = ((_c = context2.payload.pull_request) == null ? void 0 : _c.head.sha) || process.env.GITHUB_SHA || context2.sha;
      const { data: prs } = await octokit.rest.repos.listPullRequestsAssociatedWithCommit(__spreadProps(__spreadValues({}, context2.repo), {
        commit_sha: commitSha
      }));
      if (prs.length === 0) {
        return null;
      }
      const pr = prs.find((el) => context2.payload.ref === `refs/heads/${el.head.ref}`) || prs[0];
      issueNumber = pr.number;
    } catch (error) {
      return null;
    }
  }
  const { data: comments } = await octokit.rest.issues.listComments(__spreadProps(__spreadValues({}, context2.repo), {
    issue_number: issueNumber
  }));
  const existingComment = comments.find(
    (comment) => {
      var _a2;
      return (_a2 = comment.body) == null ? void 0 : _a2.includes(COMMENT_TAG);
    }
  );
  const currentTime = (/* @__PURE__ */ new Date()).toLocaleString("en-US", {
    timeZone: "UTC",
    month: "short",
    day: "numeric",
    year: "numeric",
    hour: "numeric",
    minute: "2-digit",
    hour12: true
  });
  const isStatus = ["passed", "failed", "timedout", "interrupted"].includes(input);
  const statusText = isStatus ? `${input === "passed" ? "\u2705 Tests passed" : "\u274C Tests failed"}` : "\u{1F504} Running tests";
  const body = `| ${statusText} | [View report on Artillery Cloud \u2197](${input}) | ${currentTime} |`;
  if (existingComment) {
    if (!isStatus) {
      const existingContent = existingComment.body.replace(COMMENT_TAG, "").replace(TITLE, "").replace(TABLE_HEADER, "").trim();
      const newBody = `${TITLE}${TABLE_HEADER}
${existingContent ? `${existingContent}
` : ""}${body}
${COMMENT_TAG}`;
      return octokit.rest.issues.updateComment(__spreadProps(__spreadValues({}, context2.repo), {
        comment_id: existingComment.id,
        body: newBody
      }));
    }
    const lines = existingComment.body.split("\n");
    const lastRunningIndex = lines.findIndex((line) => line.includes("Running tests"));
    if (lastRunningIndex !== -1) {
      const testUrl = (_d = lines[lastRunningIndex].match(/\(([^)]+)\)/)) == null ? void 0 : _d[1];
      if (testUrl) {
        lines[lastRunningIndex] = `| ${statusText} | [View report on Artillery Cloud \u2197](${testUrl}) | ${currentTime} |`;
        return octokit.rest.issues.updateComment(__spreadProps(__spreadValues({}, context2.repo), {
          comment_id: existingComment.id,
          body: lines.join("\n")
        }));
      }
    }
  }
  return octokit.rest.issues.createComment(__spreadProps(__spreadValues({}, context2.repo), {
    issue_number: issueNumber,
    body: `${TITLE}${TABLE_HEADER}
${body}
${COMMENT_TAG}`
  }));
}

// src/performance-tracking.ts
var WEB_VITALS_SCRIPT = `!function(e,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n((e="undefined"!=typeof globalThis?globalThis:e||self).webVitals={})}(this,(function(e){"use strict";var n,t,i,r,o,a=-1,c=function(e){addEventListener("pageshow",(function(n){n.persisted&&(a=n.timeStamp,e(n))}),!0)},u=function(){return window.performance&&performance.getEntriesByType&&performance.getEntriesByType("navigation")[0]},s=function(){var e=u();return e&&e.activationStart||0},f=function(e,n){var t=u(),i="navigate";return a>=0?i="back-forward-cache":t&&(document.prerendering||s()>0?i="prerender":document.wasDiscarded?i="restore":t.type&&(i=t.type.replace(/_/g,"-"))),{name:e,value:void 0===n?-1:n,rating:"good",delta:0,entries:[],id:"v3-".concat(Date.now(),"-").concat(Math.floor(8999999999999*Math.random())+1e12),navigationType:i}},d=function(e,n,t){try{if(PerformanceObserver.supportedEntryTypes.includes(e)){var i=new PerformanceObserver((function(e){Promise.resolve().then((function(){n(e.getEntries())}))}));return i.observe(Object.assign({type:e,buffered:!0},t||{})),i}}catch(e){}},l=function(e,n,t,i){var r,o;return function(a){n.value>=0&&(a||i)&&((o=n.value-(r||0))||void 0===r)&&(r=n.value,n.delta=o,n.rating=function(e,n){return e>n[1]?"poor":e>n[0]?"needs-improvement":"good"}(n.value,t),e(n))}},p=function(e){requestAnimationFrame((function(){return requestAnimationFrame((function(){return e()}))}))},v=function(e){var n=function(n){"pagehide"!==n.type&&"hidden"!==document.visibilityState||e(n)};addEventListener("visibilitychange",n,!0),addEventListener("pagehide",n,!0)},m=function(e){var n=!1;return function(t){n||(e(t),n=!0)}},h=-1,g=function(){return"hidden"!==document.visibilityState||document.prerendering?1/0:0},T=function(e){"hidden"===document.visibilityState&&h>-1&&(h="visibilitychange"===e.type?e.timeStamp:0,C())},y=function(){addEventListener("visibilitychange",T,!0),addEventListener("prerenderingchange",T,!0)},C=function(){removeEventListener("visibilitychange",T,!0),removeEventListener("prerenderingchange",T,!0)},E=function(){return h<0&&(h=g(),y(),c((function(){setTimeout((function(){h=g(),y()}),0)}))),{get firstHiddenTime(){return h}}},L=function(e){document.prerendering?addEventListener("prerenderingchange",(function(){return e()}),!0):e()},b=[1800,3e3],S=function(e,n){n=n||{},L((function(){var t,i=E(),r=f("FCP"),o=d("paint",(function(e){e.forEach((function(e){"first-contentful-paint"===e.name&&(o.disconnect(),e.startTime<i.firstHiddenTime&&(r.value=Math.max(e.startTime-s(),0),r.entries.push(e),t(!0)))}))}));o&&(t=l(e,r,b,n.reportAllChanges),c((function(i){r=f("FCP"),t=l(e,r,b,n.reportAllChanges),p((function(){r.value=performance.now()-i.timeStamp,t(!0)}))})))}))},w=[.1,.25],P=function(e,n){n=n||{},S(m((function(){var t,i=f("CLS",0),r=0,o=[],a=function(e){e.forEach((function(e){if(!e.hadRecentInput){var n=o[0],t=o[o.length-1];r&&e.startTime-t.startTime<1e3&&e.startTime-n.startTime<5e3?(r+=e.value,o.push(e)):(r=e.value,o=[e])}})),r>i.value&&(i.value=r,i.entries=o,t())},u=d("layout-shift",a);u&&(t=l(e,i,w,n.reportAllChanges),v((function(){a(u.takeRecords()),t(!0)})),c((function(){r=0,i=f("CLS",0),t=l(e,i,w,n.reportAllChanges),p((function(){return t()}))})),setTimeout(t,0))})))},F={passive:!0,capture:!0},I=new Date,A=function(e,r){n||(n=r,t=e,i=new Date,k(removeEventListener),M())},M=function(){if(t>=0&&t<i-I){var e={entryType:"first-input",name:n.type,target:n.target,cancelable:n.cancelable,startTime:n.timeStamp,processingStart:n.timeStamp+t};r.forEach((function(n){n(e)})),r=[]}},D=function(e){if(e.cancelable){var n=(e.timeStamp>1e12?new Date:performance.now())-e.timeStamp;"pointerdown"==e.type?function(e,n){var t=function(){A(e,n),r()},i=function(){r()},r=function(){removeEventListener("pointerup",t,F),removeEventListener("pointercancel",i,F)};addEventListener("pointerup",t,F),addEventListener("pointercancel",i,F)}(n,e):A(n,e)}},k=function(e){["mousedown","keydown","touchstart","pointerdown"].forEach((function(n){return e(n,D,F)}))},x=[100,300],B=function(e,i){i=i||{},L((function(){var o,a=E(),u=f("FID"),s=function(e){e.startTime<a.firstHiddenTime&&(u.value=e.processingStart-e.startTime,u.entries.push(e),o(!0))},p=function(e){e.forEach(s)},h=d("first-input",p);o=l(e,u,x,i.reportAllChanges),h&&v(m((function(){p(h.takeRecords()),h.disconnect()}))),h&&c((function(){var a;u=f("FID"),o=l(e,u,x,i.reportAllChanges),r=[],t=-1,n=null,k(addEventListener),a=s,r.push(a),M()}))}))},N=0,R=1/0,H=0,O=function(e){e.forEach((function(e){e.interactionId&&(R=Math.min(R,e.interactionId),H=Math.max(H,e.interactionId),N=H?(H-R)/7+1:0)}))},j=function(){return o?N:performance.interactionCount||0},_=function(){"interactionCount"in performance||o||(o=d("event",O,{type:"event",buffered:!0,durationThreshold:0}))},q=[200,500],V=0,z=function(){return j()-V},G=[],J={},K=function(e){var n=G[G.length-1],t=J[e.interactionId];if(t||G.length<10||e.duration>n.latency){if(t)t.entries.push(e),t.latency=Math.max(t.latency,e.duration);else{var i={id:e.interactionId,latency:e.duration,entries:[e]};J[i.id]=i,G.push(i)}G.sort((function(e,n){return n.latency-e.latency})),G.splice(10).forEach((function(e){delete J[e.id]}))}},Q=function(e,n){n=n||{},L((function(){_();var t,i=f("INP"),r=function(e){e.forEach((function(e){(e.interactionId&&K(e),"first-input"===e.entryType)&&(!G.some((function(n){return n.entries.some((function(n){return e.duration===n.duration&&e.startTime===n.startTime}))}))&&K(e))}));var n,r=(n=Math.min(G.length-1,Math.floor(z()/50)),G[n]);r&&r.latency!==i.value&&(i.value=r.latency,i.entries=r.entries,t())},o=d("event",r,{durationThreshold:n.durationThreshold||40});t=l(e,i,q,n.reportAllChanges),o&&(o.observe({type:"first-input",buffered:!0}),v((function(){r(o.takeRecords()),i.value<0&&z()>0&&(i.value=0,i.entries=[]),t(!0)})),c((function(){G=[],V=j(),i=f("INP"),t=l(e,i,q,n.reportAllChanges)})))}))},U=[2500,4e3],W={},X=function(e,n){n=n||{},L((function(){var t,i=E(),r=f("LCP"),o=function(e){var n=e[e.length-1];n&&n.startTime<i.firstHiddenTime&&(r.value=Math.max(n.startTime-s(),0),r.entries=[n],t())},a=d("largest-contentful-paint",o);if(a){t=l(e,r,U,n.reportAllChanges);var u=m((function(){W[r.id]||(o(a.takeRecords()),a.disconnect(),W[r.id]=!0,t(!0))}));["keydown","click"].forEach((function(e){addEventListener(e,u,!0)})),v(u),c((function(i){r=f("LCP"),t=l(e,r,U,n.reportAllChanges),p((function(){r.value=performance.now()-i.timeStamp,W[r.id]=!0,t(!0)}))}))}}))},Y=[800,1800],Z=function e(n){document.prerendering?L((function(){return e(n)})):"complete"!==document.readyState?addEventListener("load",(function(){return e(n)}),!0):setTimeout(n,0)},$=function(e,n){n=n||{};var t=f("TTFB"),i=l(e,t,Y,n.reportAllChanges);Z((function(){var r=u();if(r){var o=r.responseStart;if(o<=0||o>performance.now())return;t.value=Math.max(o-s(),0),t.entries=[r],i(!0),c((function(){t=f("TTFB",0),(i=l(e,t,Y,n.reportAllChanges))(!0)}))}}))};e.CLSThresholds=w,e.FCPThresholds=b,e.FIDThresholds=x,e.INPThresholds=q,e.LCPThresholds=U,e.TTFBThresholds=Y,e.getCLS=P,e.getFCP=S,e.getFID=B,e.getINP=Q,e.getLCP=X,e.getTTFB=$,e.onCLS=P,e.onFCP=S,e.onFID=B,e.onINP=Q,e.onLCP=X,e.onTTFB=$,Object.defineProperty(e,"__esModule",{value:!0})}));`;
var data = [];
function round(x, n) {
  return Math.round((x + Number.EPSILON) * Math.pow(10, n)) / Math.pow(10, n);
}
var withPerformanceTracking = (base) => {
  return base.extend({
    browser: async ({ browser }, use) => {
      browser.on("disconnected", () => {
      });
      await use(browser);
    },
    context: async ({ context: context2 }, use, testInfo) => {
      await context2.addInitScript(WEB_VITALS_SCRIPT);
      await context2.addInitScript(`
        ;(function() {
          window.playwrightTestId = "${testInfo.testId}";
          window.playwrightTitle = "${testInfo.title}";
        })();`);
      await context2.addInitScript(() => {
        ["onLCP", "onFCP", "onCLS", "onTTFB", "onFCP", "onINP"].forEach(
          (hook) => {
            window.webVitals[hook]((metric) => {
              console.trace(
                JSON.stringify({
                  source: "@artilleryio/playwright-reporter/performance-tracking",
                  name: metric.name,
                  value: metric.value,
                  metric,
                  url: window.location.href,
                  id: crypto.randomUUID(),
                  // @ts-ignore
                  testTitle: window.playwrightTitle,
                  // @ts-ignore
                  testId: window.playwrightTestId
                })
              );
            });
          }
        );
      });
      context2.on("close", () => {
        const entriesForThisTest = data.filter(
          (d) => d.testId === testInfo.testId
        );
        const vitalsByURL = entriesForThisTest.reduce((acc, entry) => {
          if (!acc[entry.url]) {
            acc[entry.url] = {};
          }
          if (!acc[entry.url][entry.name]) {
            acc[entry.url][entry.name] = entry.value;
          }
          return acc;
        }, {});
        for (const [url, vitals] of Object.entries(vitalsByURL)) {
          for (const [name, value] of Object.entries(vitals)) {
            testInfo.annotations.push({
              type: `Web Vitals - ${name} - ${url}`,
              description: `${round(value, 2)}`
            });
          }
        }
      });
      await use(context2);
    },
    page: async ({ page }, use, testInfo) => {
      page.on("console", (msg) => {
        if (msg.type() === "trace") {
          try {
            const metric = JSON.parse(msg.text());
            if (!metric.source || metric.source !== "@artilleryio/playwright-reporter/performance-tracking") {
              return;
            }
            const { name, value, url, testTitle, testId } = metric;
            data.push({
              title: testTitle,
              testId,
              name,
              value,
              url,
              metric
            });
          } catch (err) {
          }
        }
      });
      await use(page);
    }
  });
};

// src/index.ts
var debug = (0, import_debug.default)("artillery-playwright-reporter");
function createGuid() {
  return import_node_crypto.default.randomBytes(16).toString("hex");
}
function createHash(filepath) {
  const sha = import_node_crypto.default.createHash("sha256").update(filepath).digest("hex");
  return `${sha}-${path.basename(filepath)}`;
}
function serializeRegexPatterns(patterns) {
  if (!Array.isArray(patterns)) patterns = [patterns];
  return patterns.map((s) => {
    if (typeof s === "string") return { s };
    return { r: { source: s.source, flags: s.flags } };
  });
}
var ArtilleryReporter = class {
  constructor(options) {
    this._idSymbol = Symbol("id");
    this.version = version;
    this.options = {
      enabled: true,
      testRunId: this.generateId("pw"),
      apiKey: options.apiKey,
      name: options.name || process2.env.ARTILLERY_PLAYWRIGHT_TEST_RUN_NAME || "Playwright test suite"
    };
    this.client = new ArtilleryCloudClient({
      apiKey: this.options.apiKey || "",
      testRunId: this.options.testRunId
    });
    this.actions = [];
  }
  printsToStdio() {
    return true;
  }
  onBegin(config, suite) {
    this._rootDir = config.rootDir;
    this.options.apiKey = process2.env.ARTILLERY_CLOUD_API_KEY;
    this.options.baseDir = path.dirname(config.configFile || process2.cwd());
    if (!this.options.apiKey) {
      console.error("Artillery Cloud API key is required");
      this.options.enabled = false;
    }
    if (config.shard !== null) {
      console.error(
        "Artillery Reporter does not merge reports from sharded test runs yet"
      );
    }
    this.options.enabled = true;
    const testRunName = config.shard !== null ? `${this.options.name} (${config.shard.current}/${config.shard.total})` : this.options.name;
    this.actions.push(
      this.client.initTestRun({
        testRunName,
        metadata: {
          reporterVersion: this.version,
          playwrightConfig: config
        }
      })
    );
    this.actions.push(
      this.createTestRunEvent("onConfigure", {
        config: {
          configFile: this._relativePath(config.configFile),
          globalTimeout: config.globalTimeout,
          maxFailures: config.maxFailures,
          metadata: config.metadata,
          rootDir: this._relativePath(config.rootDir),
          version: config.version,
          workers: config.workers
        }
      })
    );
    const projects = suite.suites.map(
      (projectSuite) => this._parseProject(projectSuite)
    );
    for (const project of projects) {
      this.actions.push(this.createTestRunEvent("onProject", { project }));
    }
    this.actions.push(this.createTestRunEvent("onBegin", void 0));
  }
  onTestBegin(test, result) {
    if (!this.options.enabled) {
      return;
    }
    result[this._idSymbol] = createGuid();
    this.actions.push(
      this.createTestRunEvent("onTestBegin", {
        testId: test.id,
        result: {
          id: result[this._idSymbol],
          parallelIndex: result.parallelIndex,
          retry: result.retry,
          startTime: result.startTime,
          workerIndex: result.workerIndex
        }
      })
    );
  }
  onStepBegin(test, result, step) {
    var _a;
    step[this._idSymbol] = createGuid();
    this.actions.push(
      this.createTestRunEvent("onStepBegin", {
        resultId: result[this._idSymbol],
        testId: test.id,
        step: {
          id: step[this._idSymbol],
          parentStepId: (_a = step.parent) == null ? void 0 : _a[this._idSymbol],
          title: step.title,
          category: step.category,
          startTime: +step.startTime,
          location: this._relativeLocation(step.location)
        }
      })
    );
  }
  onStepEnd(test, result, step) {
    var _a;
    this.actions.push(
      this.createTestRunEvent("onStepEnd", {
        testId: test.id,
        resultId: result[this._idSymbol],
        step: {
          id: step[this._idSymbol],
          duration: step.duration,
          error: step.error,
          parentStepId: (_a = step.parent) == null ? void 0 : _a[this._idSymbol],
          attachments: this._serializeAttachments(result.attachments),
          title: step.title,
          category: step.category,
          startTime: step.startTime,
          location: this._relativeLocation(step.location)
        }
      })
    );
  }
  onTestEnd(test, result) {
    if (!this.options.enabled) {
      return;
    }
    this.actions.push(
      this.createTestRunEvent("onTestEnd", {
        test: {
          testId: test.id,
          expectedStatus: test.expectedStatus,
          annotations: test.annotations,
          timeout: test.timeout
        },
        result: {
          id: result[this._idSymbol],
          duration: result.duration,
          status: result.status,
          errors: result.errors,
          attachments: this._serializeAttachments(result.attachments)
        }
      })
    );
    for (const attachment of result.attachments) {
      if (attachment.path) {
        const mimeType = attachment.contentType;
        this.actions.push(
          this.client.uploadAttachment(
            attachment.path,
            "playwright-testrunner-attachment",
            mimeType
          )
        );
      }
    }
  }
  onStdErr(chunk, test, result) {
    this.actions.push(
      this.createTestRunEvent(
        "onStdIO",
        this._onStdIO("stderr", chunk, test, result)
      )
    );
  }
  onStdOut(chunk, test, result) {
    this.actions.push(
      this.createTestRunEvent(
        "onStdIO",
        this._onStdIO("stdout", chunk, test, result)
      )
    );
  }
  async onEnd(result) {
    if (!this.options.enabled) {
      return;
    }
    this.actions.push(
      this.createTestRunEvent("onEnd", {
        result: {
          duration: result.duration,
          startTime: result.startTime,
          status: result.status
        }
      })
    );
    this.actions.push(
      this.client.endTestRun({
        ts: result.startTime.getTime() + result.duration,
        exitCode: result.status === "passed" ? 0 : 1,
        isEarlyStop: result.status === "interrupted"
      })
    );
    const results = await Promise.allSettled(this.actions);
    const rejections = results.filter((r) => r.status === "rejected");
    if (rejections.length > 0) {
      console.error(
        "Error: error sending some of the test data to Artillery Cloud"
      );
      console.error("Test report may be incomplete");
    }
    await createOrUpdateComment(result.status);
    if ((result == null ? void 0 : result.status) !== "passed") {
      core.setFailed("Tests failed");
    }
  }
  onError(error) {
    this.actions.push(this.createTestRunEvent("onError", { error }));
  }
  onExit() {
    return Promise.resolve();
  }
  generateId(prefix = "") {
    const idf = (0, import_nanoid.customAlphabet)("3456789abcdefghjkmnpqrtwxyz");
    const testRunId = `${prefix}${idf(4)}_${idf(29)}_${idf(4)}`;
    return testRunId;
  }
  createTestRunEvent(method, params) {
    return this.client._event("testrun:event", {
      eventName: "playwright:testrunner",
      eventAttributes: {
        method,
        params
      }
    });
  }
  _parseProject(projectSuite) {
    const project = projectSuite.project();
    return {
      metadata: project.metadata,
      name: project.name,
      outputDir: this._relativePath(project.outputDir),
      repeatEach: project.repeatEach,
      retries: project.retries,
      testDir: this._relativePath(project.testDir),
      testIgnore: serializeRegexPatterns(project.testIgnore),
      testMatch: serializeRegexPatterns(project.testMatch),
      timeout: project.timeout,
      suites: projectSuite.suites.map((suite) => this._parseSuite(suite)),
      grep: serializeRegexPatterns(project.grep),
      grepInvert: serializeRegexPatterns(project.grepInvert || []),
      dependencies: project.dependencies,
      snapshotDir: project.snapshotDir,
      teardown: project.teardown
    };
  }
  _parseSuite(suite) {
    return {
      title: suite.title,
      location: this._relativeLocation(suite.location),
      entries: suite.entries().map(
        (entry) => entry.type === "test" ? this._parseTest(entry) : this._parseSuite(entry)
      )
    };
  }
  _parseTest(test) {
    return {
      title: test.title,
      location: this._relativeLocation(test.location),
      type: "test",
      testId: test.id,
      annotations: test.annotations,
      repeatEachIndex: test.repeatEachIndex,
      retries: test.retries,
      tags: test.tags
    };
  }
  _onStdIO(type, chunk, test, result) {
    const isBase64 = typeof chunk !== "string";
    const data2 = isBase64 ? chunk.toString("base64") : chunk;
    return {
      testId: test == null ? void 0 : test.id,
      resultId: result ? result[this._idSymbol] : void 0,
      type,
      data: data2,
      isBase64,
      timestamp: Date.now()
    };
  }
  _serializeAttachments(attachments) {
    return attachments.map((a) => __spreadProps(__spreadValues({}, a), {
      // There is no Buffer in the browser, so there is no point in sending the data there.
      base64: a.body ? a.body.toString("base64") : void 0,
      hash: a.path ? createHash(a.path) : void 0
    }));
  }
  _relativePath(absolutePath) {
    if (!absolutePath) return absolutePath;
    return path.relative(this._rootDir, absolutePath);
  }
  _relativeLocation(location) {
    if (!location) return location;
    return __spreadProps(__spreadValues({}, location), {
      file: this._relativePath(location.file)
    });
  }
};
var ArtilleryCloudClient = class {
  constructor(opts) {
    this.orgId = null;
    this.enabled = false;
    this.initialized = false;
    const apiKey = opts.apiKey || process2.env.ARTILLERY_CLOUD_API_KEY;
    if (!apiKey) {
      throw new Error("Artillery Cloud API key is required");
    }
    this.apiKey = apiKey;
    this.testRunId = opts.testRunId;
    this.baseUrl = process2.env.ARTILLERY_CLOUD_ENDPOINT || "https://app.artillery.io";
    this.whoamiEndpoint = `${this.baseUrl}/api/user/whoami`;
    this.eventsEndpoint = `${this.baseUrl}/api/events`;
    this.getAssetUploadUrls = `${this.baseUrl}/api/asset-upload-urls`;
    const version2 = "dev";
    this.defaultHeaders = {
      "x-auth-token": this.apiKey,
      "user-agent": `Artillery Playwright Reporter ${version2}`
    };
  }
  async initTestRun(opts) {
    let ciURL = null;
    let ghaMetadata = {};
    if (import_ci_info.isCI && import_ci_info.name === "GitHub Actions") {
      const { GITHUB_SERVER_URL, GITHUB_REPOSITORY, GITHUB_RUN_ID } = process2.env;
      if (GITHUB_SERVER_URL && GITHUB_REPOSITORY && GITHUB_RUN_ID) {
        ciURL = `${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}`;
      }
      ghaMetadata = {
        GITHUB_ACTION_REPOSITORY: process2.env.GITHUB_ACTION_REPOSITORY,
        GITHUB_REF: process2.env.GITHUB_REF,
        GITHUB_REF_NAME: process2.env.GITHUB_REF_NAME,
        GITHUB_REF_TYPE: process2.env.GITHUB_REF_TYPE,
        GITHUB_REPOSITORY: process2.env.GITHUB_REPOSITORY,
        GITHUB_RUNNER_ENVIRONMENT: process2.env.GITHUB_RUNNER_ENVIRONMENT,
        GITHUB_SERVER_URL: process2.env.GITHUB_SERVER_URL,
        GITHUB_SHA: process2.env.GITHUB_SHA,
        GITHUB_TRIGGERING_ACTOR: process2.env.GITHUB_TRIGGERING_ACTOR,
        GITHUB_WORKFLOW: process2.env.GITHUB_WORKFLOW
      };
    }
    let res;
    let body;
    try {
      res = await import_got.default.get(this.whoamiEndpoint, {
        headers: this.defaultHeaders,
        throwHttpErrors: false,
        retry: {
          limit: 3
        }
      });
      body = JSON.parse(res.body);
      this.orgId = body.activeOrg;
    } catch (err) {
      console.log(err);
    }
    if (!res) {
      console.log(
        "Error: Could not connect to Artillery Cloud. Check your API key."
      );
      this.enabled = false;
      this.initialized = true;
      return;
    }
    if (res.statusCode === 401) {
      console.log(
        "Error: API key is invalid. Could not send test data to Artillery Cloud."
      );
      this.enabled = false;
      this.initialized = true;
      return;
    }
    this.enabled = true;
    const tags = [
      {
        name: "name",
        value: opts.testRunName
      }
    ];
    const metadata = {
      testType: "playwright-test-runner",
      isCI: import_ci_info.isCI,
      ciName: import_ci_info.name,
      ciURL,
      tags,
      reporterVersion: opts.metadata.reporterVersion,
      playwrightConfig: opts.metadata.playwrightConfig,
      ciInfo: ghaMetadata,
      os: {
        type: import_node_os.default.type(),
        platform: import_node_os.default.platform(),
        release: import_node_os.default.release()
      }
    };
    await this._event(
      "testrun:init",
      {
        metadata
      },
      { nowait: true }
    );
    this.initialized = true;
    const testResultsURL = `${this.baseUrl}/${this.orgId}/playwright/${this.testRunId}`;
    console.log(testResultsURL);
    await createOrUpdateComment(testResultsURL);
  }
  async endTestRun({ ts, exitCode, isEarlyStop }) {
    if (!this.enabled) {
      return;
    }
    await this._event("testrun:end", {
      ts,
      exitCode,
      isEarlyStop,
      report: {}
    });
  }
  async uploadAttachment(filepath, assetType, mimeType) {
    if (!this.enabled) {
      return;
    }
    const hash = createHash(filepath);
    const payload = Object.assign(
      {
        testRunId: this.testRunId,
        filenames: [hash],
        assetType
      },
      mimeType ? { mimeType } : {}
    );
    let url;
    try {
      const res = await import_got.default.post(this.getAssetUploadUrls, {
        headers: this.defaultHeaders,
        throwHttpErrors: false,
        json: payload
      });
      const body = JSON.parse(res.body);
      url = body.urls[hash];
    } catch (error) {
      console.error(error);
    }
    if (!url) {
      return;
    }
    try {
      const _res = await import_got.default.put(url, {
        headers: {},
        body: fs.readFileSync(filepath)
      });
    } catch (error) {
      console.error("Failed to upload Playwright trace recording:", error);
      console.log(error.code, error.name, error.message, error.stack);
    }
    return url;
  }
  // TODO: This should be replaced with a task queue, where test:init
  // is always sent firt, and everything else is guaranteed to be sent
  // in order - right now because each send spins and waits some events
  // may get sent out of order
  async _event(eventName, eventPayload, opts = { nowait: false }) {
    if (!this.initialized && !opts.nowait) {
      const maxWaitMsec = 2e4;
      const wait = 100;
      let elapsed = 0;
      while (true) {
        await (0, import_promises.setTimeout)(wait);
        elapsed += wait;
        if (this.initialized) {
          break;
        }
        if (elapsed > maxWaitMsec) {
          return;
        }
      }
    }
    if (!this.enabled && this.initialized) {
      return;
    }
    try {
      const res = await import_got.default.post(this.eventsEndpoint, {
        headers: this.defaultHeaders,
        json: {
          eventType: eventName,
          eventData: Object.assign({}, eventPayload, {
            testRunId: this.testRunId
          })
        },
        throwHttpErrors: false,
        retry: {
          limit: 3,
          methods: ["POST"]
        }
      });
      if (res.statusCode != 200) {
        if (res.statusCode == 401) {
          console.error(
            "Error: API key is invalid. Could not send test data to Artillery Cloud."
          );
        } else {
          console.error("Error: error sending test data to Artillery Cloud");
          console.log("Test report may be incomplete");
        }
        let body;
        try {
          body = JSON.parse(res.body);
        } catch (_err) {
        }
        if (body && body.requestId) {
          console.log("Request ID:", body.requestId);
        }
      }
      debug("\u2601\uFE0F", eventName, eventPayload.eventName, "sent");
    } catch (err) {
      debug(err);
    }
  }
};
var src_default = ArtilleryReporter;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  withPerformanceTracking
});
